<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/registro_usuarios_ctk/controller/app_controller.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/registro_usuarios_ctk/controller/app_controller.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;from registro_usuarios_ctk.model.usuario_model import GestorUsuarios, Usuario&#10;from registro_usuarios_ctk.view.main_view import MainView, AddUserView&#10;from pathlib import Path&#10;from tkinter import messagebox, PhotoImage&#10;&#10;&#10;class AppController:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.gestor = GestorUsuarios()&#10;        self.view = MainView(root)&#10;&#10;        # base dir and assets folder&#10;        self.BASE_DIR = Path(__file__).resolve().parent.parent&#10;        self.ASSETS_PATH = self.BASE_DIR / &quot;assets&quot;&#10;&#10;        # image cache to keep PhotoImage references&#10;        self.avatar_images = {}&#10;&#10;        # hook exit handler&#10;        self.view.on_exit = self.on_exit&#10;&#10;        # initial population&#10;        self.refrescar_lista_usuarios()&#10;&#10;        # connect add button&#10;        try:&#10;            self.view.btn_anadir.configure(command=self.abrir_ventana_añadir)&#10;        except Exception:&#10;            pass&#10;&#10;        # connect File menu commands&#10;        try:&#10;            self.CSV_PATH = self.BASE_DIR / &quot;data&quot; / &quot;users.csv&quot;&#10;            # Spanish labels: first 'Cargar' then 'Guardar', plus a separator and 'Salir'&#10;            self.view.menu_archivo.add_command(label=&quot;Cargar&quot;, command=self.cargar_usuarios)&#10;            self.view.menu_archivo.add_command(label=&quot;Guardar&quot;, command=self.guardar_usuarios)&#10;            self.view.menu_archivo.add_separator()&#10;            self.view.menu_archivo.add_command(label=&quot;Salir&quot;, command=self.on_exit)&#10;        except Exception:&#10;            pass&#10;&#10;        # attempt initial load&#10;        try:&#10;            self.cargar_usuarios()&#10;        except Exception:&#10;            pass&#10;&#10;    def refrescar_lista_usuarios(self):&#10;        &quot;&quot;&quot;Get users from model and update the view with selection callback.&quot;&quot;&quot;&#10;        usuarios = self.gestor.listar()&#10;        self.view.actualizar_lista_usuarios(usuarios, self.seleccionar_usuario)&#10;&#10;    def seleccionar_usuario(self, indice: int):&#10;        &quot;&quot;&quot;Callback from view with index of selected user.&quot;&quot;&quot;&#10;        usuarios = self.gestor.listar()&#10;        try:&#10;            usuario = usuarios[indice]&#10;        except Exception:&#10;            # index invalid: show empty details&#10;            self.view.mostrar_detalles_usuario(None)&#10;            return&#10;&#10;        # try to load avatar if provided&#10;        if usuario.avatar:&#10;            avatar_path = (self.ASSETS_PATH / usuario.avatar).resolve()&#10;            if avatar_path.exists():&#10;                try:&#10;                    img = PhotoImage(file=str(avatar_path))&#10;                    # keep reference&#10;                    self.avatar_images[usuario.avatar] = img&#10;                    try:&#10;                        self.view.lbl_avatar.configure(image=img, text=&quot;&quot;)&#10;                    except Exception:&#10;                        self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar}&quot;)&#10;                except Exception:&#10;                    self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar} (could not load)&quot;)&#10;            else:&#10;                self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar} (not found)&quot;)&#10;        else:&#10;            # remove previous image and show default text&#10;            try:&#10;                self.view.lbl_avatar.configure(image=&quot;&quot;, text=&quot;Avatar: -&quot;)&#10;            except Exception:&#10;                self.view.lbl_avatar.configure(text=&quot;Avatar: -&quot;)&#10;&#10;        # finally show details (text labels)&#10;        self.view.mostrar_detalles_usuario(usuario)&#10;&#10;    def abrir_ventana_añadir(self):&#10;        &quot;&quot;&quot;Open the AddUser modal and connect save button.&quot;&quot;&quot;&#10;        add_view = AddUserView(self.root)&#10;        add_view.guardar_button.configure(command=lambda: self.añadir_usuario(add_view))&#10;&#10;    def añadir_usuario(self, add_view: AddUserView):&#10;        data = add_view.get_data()&#10;        # validate age&#10;        try:&#10;            edad = int(data.get(&quot;edad&quot;, &quot;0&quot;))&#10;        except ValueError:&#10;            messagebox.showerror(&quot;Invalid age&quot;, &quot;Age must be an integer&quot;)&#10;            return&#10;&#10;        nombre = data.get(&quot;nombre&quot;)&#10;        genero = data.get(&quot;genero&quot;)&#10;        avatar = data.get(&quot;avatar&quot;) or None&#10;&#10;        if not nombre:&#10;            messagebox.showerror(&quot;Incomplete data&quot;, &quot;Name is required&quot;)&#10;            return&#10;&#10;        # create and add user&#10;        u = Usuario(nombre=nombre, edad=edad, genero=genero, avatar=avatar)&#10;        self.gestor.add(u)&#10;&#10;        # refresh view and close modal&#10;        self.refrescar_lista_usuarios()&#10;        try:&#10;            add_view.window.destroy()&#10;        except Exception:&#10;            pass&#10;&#10;    def on_exit(self):&#10;        if messagebox.askokcancel(&quot;Exit&quot;, &quot;Do you want to exit the application?&quot;):&#10;            try:&#10;                self.root.destroy()&#10;            except Exception:&#10;                pass&#10;&#10;    def guardar_usuarios(self):&#10;        try:&#10;            self.gestor.guardar_csv(self.CSV_PATH)&#10;            messagebox.showinfo(&quot;Saved&quot;, f&quot;Users saved to {self.CSV_PATH}&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;Save error&quot;, str(e))&#10;&#10;    def cargar_usuarios(self):&#10;        try:&#10;            self.gestor.cargar_csv(self.CSV_PATH)&#10;            self.refrescar_lista_usuarios()&#10;            messagebox.showinfo(&quot;Loaded&quot;, f&quot;Users loaded from {self.CSV_PATH}&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;Load error&quot;, str(e))&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;from registro_usuarios_ctk.model.usuario_model import GestorUsuarios, Usuario&#10;from registro_usuarios_ctk.view.main_view import MainView, AddUserView&#10;from pathlib import Path&#10;from tkinter import messagebox, PhotoImage&#10;&#10;&#10;class AppController:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.gestor = GestorUsuarios()&#10;        self.view = MainView(root)&#10;&#10;        # base dir and assets folder&#10;        self.BASE_DIR = Path(__file__).resolve().parent.parent&#10;        self.ASSETS_PATH = self.BASE_DIR / &quot;assets&quot;&#10;&#10;        # image cache to keep PhotoImage references&#10;        self.avatar_images = {}&#10;&#10;        # state for filtering/search&#10;        self.current_search = &quot;&quot;&#10;        self.current_filter = &quot;Todos&quot;&#10;        self._filtered_indexes = []  # mapea índice visible -&gt; índice en gestor&#10;&#10;        # hook exit handler&#10;        self.view.on_exit = self.on_exit&#10;&#10;        # connect callbacks from view&#10;        self.view.on_search_change = self.on_search_change&#10;        self.view.on_filter_change = self.on_filter_change&#10;&#10;        # initial population&#10;        self.refrescar_lista_usuarios()&#10;&#10;        # connect add button&#10;        try:&#10;            self.view.btn_anadir.configure(command=self.abrir_ventana_añadir)&#10;        except Exception:&#10;            pass&#10;&#10;        # connect File menu commands&#10;        try:&#10;            self.CSV_PATH = self.BASE_DIR / &quot;data&quot; / &quot;users.csv&quot;&#10;            # Spanish labels: first 'Cargar' then 'Guardar', plus a separator and 'Salir'&#10;            self.view.menu_archivo.add_command(label=&quot;Cargar&quot;, command=self.cargar_usuarios)&#10;            self.view.menu_archivo.add_command(label=&quot;Guardar&quot;, command=self.guardar_usuarios)&#10;            self.view.menu_archivo.add_separator()&#10;            self.view.menu_archivo.add_command(label=&quot;Salir&quot;, command=self.on_exit)&#10;        except Exception:&#10;            pass&#10;&#10;        # attempt initial load&#10;        try:&#10;            self.cargar_usuarios()&#10;        except Exception:&#10;            pass&#10;&#10;    def refrescar_lista_usuarios(self):&#10;        &quot;&quot;&quot;Get users from model, apply filters, and update the view with callbacks.&quot;&quot;&quot;&#10;        usuarios = self.gestor.listar()&#10;&#10;        # apply search and filter to build a visible list and mapping&#10;        visible = []&#10;        self._filtered_indexes = []&#10;        s = self.current_search.strip().lower()&#10;        f = self.current_filter&#10;        for idx, u in enumerate(usuarios):&#10;            if f != &quot;Todos&quot; and u.genero and u.genero.lower() != f.lower():&#10;                continue&#10;            if s and s not in u.nombre.lower():&#10;                continue&#10;            visible.append(u)&#10;            self._filtered_indexes.append(idx)&#10;&#10;        # update status with counts&#10;        self.view.set_status(f&quot;Mostrando {len(visible)} de {len(usuarios)} usuarios&quot;)&#10;&#10;        # pass the visible list and callbacks; double click maps visible index -&gt; real index&#10;        self.view.actualizar_lista_usuarios(visible, self.seleccionar_usuario_visible, self.editar_usuario_visible)&#10;&#10;    def seleccionar_usuario_visible(self, visible_index: int):&#10;        &quot;&quot;&quot;Cuando la vista pasa un índice visible, lo convertimos al índice real y mostramos detalles.&quot;&quot;&quot;&#10;        try:&#10;            real_idx = self._filtered_indexes[visible_index]&#10;        except Exception:&#10;            self.view.mostrar_detalles_usuario(None)&#10;            return&#10;        usuario = self.gestor.get(real_idx)&#10;        if usuario is None:&#10;            self.view.mostrar_detalles_usuario(None)&#10;            return&#10;&#10;        # cargar avatar similar a antes&#10;        if usuario.avatar:&#10;            avatar_path = (self.ASSETS_PATH / usuario.avatar).resolve()&#10;            if avatar_path.exists():&#10;                try:&#10;                    img = PhotoImage(file=str(avatar_path))&#10;                    self.avatar_images[usuario.avatar] = img&#10;                    try:&#10;                        self.view.lbl_avatar.configure(image=img, text=&quot;&quot;)&#10;                    except Exception:&#10;                        self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar}&quot;)&#10;                except Exception:&#10;                    self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar} (could not load)&quot;)&#10;            else:&#10;                self.view.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar} (not found)&quot;)&#10;        else:&#10;            try:&#10;                self.view.lbl_avatar.configure(image=&quot;&quot;, text=&quot;Avatar: -&quot;)&#10;            except Exception:&#10;                self.view.lbl_avatar.configure(text=&quot;Avatar: -&quot;)&#10;&#10;        # finally show details&#10;        self.view.mostrar_detalles_usuario(usuario)&#10;&#10;    def editar_usuario_visible(self, visible_index: int):&#10;        &quot;&quot;&quot;Abre modal de edición para el usuario visible, actualiza en el modelo y refresca.&quot;&quot;&quot;&#10;        try:&#10;            real_idx = self._filtered_indexes[visible_index]&#10;        except Exception:&#10;            return&#10;        usuario = self.gestor.get(real_idx)&#10;        if usuario is None:&#10;            return&#10;&#10;        add_view = AddUserView(self.root, usuario=usuario)&#10;        # conectar guardar para actualizar&#10;        def do_update():&#10;            data = add_view.get_data()&#10;            try:&#10;                edad = int(data.get(&quot;edad&quot;, &quot;0&quot;))&#10;            except ValueError:&#10;                messagebox.showerror(&quot;Edad inválida&quot;, &quot;La edad debe ser un entero&quot;)&#10;                return&#10;            nombre = data.get(&quot;nombre&quot;)&#10;            genero = data.get(&quot;genero&quot;)&#10;            avatar = data.get(&quot;avatar&quot;) or None&#10;            if not nombre:&#10;                messagebox.showerror(&quot;Datos incompletos&quot;, &quot;El nombre es obligatorio&quot;)&#10;                return&#10;            nuevo = Usuario(nombre=nombre, edad=edad, genero=genero, avatar=avatar)&#10;            ok = self.gestor.update(real_idx, nuevo)&#10;            if ok:&#10;                self.view.set_status(&quot;Usuario actualizado&quot;)&#10;                self.refrescar_lista_usuarios()&#10;                try:&#10;                    add_view.window.destroy()&#10;                except Exception:&#10;                    pass&#10;            else:&#10;                messagebox.showerror(&quot;Error&quot;, &quot;No se pudo actualizar el usuario&quot;)&#10;&#10;        add_view.guardar_button.configure(command=do_update)&#10;&#10;    def on_search_change(self, text: str):&#10;        self.current_search = text&#10;        self.refrescar_lista_usuarios()&#10;&#10;    def on_filter_change(self, value: str):&#10;        self.current_filter = value&#10;        self.refrescar_lista_usuarios()&#10;&#10;    def abrir_ventana_añadir(self):&#10;        &quot;&quot;&quot;Open the AddUser modal and connect save button.&quot;&quot;&quot;&#10;        add_view = AddUserView(self.root)&#10;        add_view.guardar_button.configure(command=lambda: self.añadir_usuario(add_view))&#10;&#10;    def añadir_usuario(self, add_view: AddUserView):&#10;        data = add_view.get_data()&#10;        # validate age&#10;        try:&#10;            edad = int(data.get(&quot;edad&quot;, &quot;0&quot;))&#10;        except ValueError:&#10;            messagebox.showerror(&quot;Invalid age&quot;, &quot;Age must be an integer&quot;)&#10;            return&#10;&#10;        nombre = data.get(&quot;nombre&quot;)&#10;        genero = data.get(&quot;genero&quot;)&#10;        avatar = data.get(&quot;avatar&quot;) or None&#10;&#10;        if not nombre:&#10;            messagebox.showerror(&quot;Incomplete data&quot;, &quot;Name is required&quot;)&#10;            return&#10;&#10;        # create and add user&#10;        u = Usuario(nombre=nombre, edad=edad, genero=genero, avatar=avatar)&#10;        self.gestor.add(u)&#10;&#10;        # refresh view and close modal&#10;        self.refrescar_lista_usuarios()&#10;        try:&#10;            add_view.window.destroy()&#10;        except Exception:&#10;            pass&#10;&#10;    def on_exit(self):&#10;        if messagebox.askokcancel(&quot;Exit&quot;, &quot;Do you want to exit the application?&quot;):&#10;            try:&#10;                self.root.destroy()&#10;            except Exception:&#10;                pass&#10;&#10;    def guardar_usuarios(self):&#10;        try:&#10;            self.gestor.guardar_csv(self.CSV_PATH)&#10;            messagebox.showinfo(&quot;Saved&quot;, f&quot;Users saved to {self.CSV_PATH}&quot;)&#10;            self.view.set_status(&quot;Guardado OK&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;Save error&quot;, str(e))&#10;            self.view.set_status(f&quot;Error al guardar: {e}&quot;)&#10;&#10;    def cargar_usuarios(self):&#10;        try:&#10;            self.gestor.cargar_csv(self.CSV_PATH)&#10;            self.refrescar_lista_usuarios()&#10;            messagebox.showinfo(&quot;Loaded&quot;, f&quot;Users loaded from {self.CSV_PATH}&quot;)&#10;            self.view.set_status(&quot;Usuarios cargados&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;Load error&quot;, str(e))&#10;            self.view.set_status(f&quot;Error al cargar: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/registro_usuarios_ctk/view/main_view.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/registro_usuarios_ctk/view/main_view.py" />
              <option name="originalContent" value="import customtkinter as ctk&#10;from typing import Callable, Optional, List&#10;from registro_usuarios_ctk.model.usuario_model import Usuario&#10;import tkinter&#10;&#10;&#10;class MainView:&#10;    &quot;&quot;&quot;Vista principal: grid de 2 columnas con lista a la izquierda y detalles a la derecha.&quot;&quot;&quot;&#10;&#10;    def __init__(self, root):&#10;        self.root = root&#10;        # crear la barra de menú (la vista sólo crea los contenedores)&#10;        self.menubar = tkinter.Menu(root)&#10;        root.config(menu=self.menubar)&#10;        self.menu_archivo = tkinter.Menu(self.menubar, tearoff=0)&#10;        self.menubar.add_cascade(label=&quot;Archivo&quot;, menu=self.menu_archivo)&#10;&#10;        # callbacks que el controlador asignará&#10;        self.on_seleccionar_usuario: Optional[Callable[[int], None]] = None&#10;        self.on_exit: Optional[Callable[[], None]] = None&#10;&#10;        # configurar grid&#10;        root.grid_columnconfigure(0, weight=1)&#10;        root.grid_columnconfigure(1, weight=2)&#10;        root.grid_rowconfigure(0, weight=1)&#10;        root.grid_rowconfigure(1, weight=0)&#10;&#10;        # panel izquierdo: lista scrollable&#10;        self.lista_usuarios_frame = ctk.CTkFrame(root)&#10;        self.lista_usuarios_frame.grid(row=0, column=0, sticky=&quot;nsew&quot;, padx=8, pady=8)&#10;&#10;        # título para la lista&#10;        self.lbl_usuarios_title = ctk.CTkLabel(self.lista_usuarios_frame, text=&quot;Usuarios&quot;, font=(&quot;Arial&quot;, 14, &quot;bold&quot;))&#10;        self.lbl_usuarios_title.pack(anchor=&quot;nw&quot;, padx=4, pady=(2, 6))&#10;&#10;        self.lista_usuarios_scrollable = ctk.CTkScrollableFrame(self.lista_usuarios_frame)&#10;        self.lista_usuarios_scrollable.pack(fill=&quot;both&quot;, expand=True, padx=4, pady=4)&#10;&#10;        # panel derecho: detalles&#10;        self.detalles_frame = ctk.CTkFrame(root)&#10;        self.detalles_frame.grid(row=0, column=1, sticky=&quot;nsew&quot;, padx=8, pady=8)&#10;&#10;        # título para detalles&#10;        self.lbl_detalles_title = ctk.CTkLabel(self.detalles_frame, text=&quot;Detalles del Usuario&quot;, font=(&quot;Arial&quot;, 14, &quot;bold&quot;))&#10;        self.lbl_detalles_title.pack(anchor=&quot;nw&quot;, pady=(2, 6))&#10;&#10;        self.lbl_nombre = ctk.CTkLabel(self.detalles_frame, text=&quot;Nombre: -&quot;)&#10;        self.lbl_nombre.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_edad = ctk.CTkLabel(self.detalles_frame, text=&quot;Edad: -&quot;)&#10;        self.lbl_edad.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_genero = ctk.CTkLabel(self.detalles_frame, text=&quot;Género: -&quot;)&#10;        self.lbl_genero.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_avatar = ctk.CTkLabel(self.detalles_frame, text=&quot;Avatar: -&quot;)&#10;        self.lbl_avatar.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        # footer: ocupar la segunda fila (row=1) y spanear ambas columnas&#10;        self.footer_frame = ctk.CTkFrame(root)&#10;        self.footer_frame.grid(row=1, column=0, columnspan=2, sticky=&quot;ew&quot;, padx=8, pady=(0, 8))&#10;&#10;        # botón Salir a la derecha&#10;        self.btn_salir = ctk.CTkButton(self.footer_frame, text=&quot;Salir&quot;, command=self._on_exit_clicked)&#10;        self.btn_salir.pack(side=&quot;right&quot;, padx=8, pady=4)&#10;&#10;        # botón Añadir a la izquierda&#10;        self.btn_anadir = ctk.CTkButton(self.footer_frame, text=&quot;Añadir&quot;)&#10;        self.btn_anadir.pack(side=&quot;left&quot;, padx=8, pady=4)&#10;&#10;    def _on_exit_clicked(self):&#10;        if self.on_exit:&#10;            try:&#10;                self.on_exit()&#10;                return&#10;            except Exception:&#10;                # si el callback falla, fallback a cerrar la ventana&#10;                pass&#10;        try:&#10;            self.root.destroy()&#10;        except Exception:&#10;            pass&#10;&#10;    def actualizar_lista_usuarios(self, usuarios: List[Usuario], on_seleccionar_callback: Callable[[int], None]):&#10;        &quot;&quot;&quot;Rellena el CTkScrollableFrame con botones para cada usuario.&#10;        Cada botón llama al callback pasado con el índice del usuario.&#10;        &quot;&quot;&quot;&#10;        # limpiar contenido previo&#10;        for child in self.lista_usuarios_scrollable.winfo_children():&#10;            child.destroy()&#10;&#10;        for i, usuario in enumerate(usuarios):&#10;            btn = ctk.CTkButton(&#10;                self.lista_usuarios_scrollable,&#10;                text=usuario.nombre,&#10;                command=lambda idx=i: on_seleccionar_callback(idx),&#10;            )&#10;            btn.pack(fill=&quot;x&quot;, padx=5, pady=2)&#10;&#10;    def mostrar_detalles_usuario(self, usuario: Optional[Usuario]):&#10;        &quot;&quot;&quot;Actualiza los CTkLabel con los datos del usuario.&quot;&quot;&quot;&#10;        if usuario is None:&#10;            self.lbl_nombre.configure(text=&quot;Nombre: -&quot;)&#10;            self.lbl_edad.configure(text=&quot;Edad: -&quot;)&#10;            self.lbl_genero.configure(text=&quot;Género: -&quot;)&#10;            self.lbl_avatar.configure(text=&quot;Avatar: -&quot;)&#10;            return&#10;&#10;        self.lbl_nombre.configure(text=f&quot;Nombre: {usuario.nombre}&quot;)&#10;        self.lbl_edad.configure(text=f&quot;Edad: {usuario.edad}&quot;)&#10;        self.lbl_genero.configure(text=f&quot;Género: {usuario.genero}&quot;)&#10;        self.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar or '-'}&quot;)&#10;&#10;&#10;class AddUserView:&#10;    &quot;&quot;&quot;Ventana modal para añadir un nuevo usuario.&quot;&quot;&quot;&#10;&#10;    def __init__(self, master):&#10;        self.window = ctk.CTkToplevel(master)&#10;        self.window.title(&quot;Añadir Nuevo Usuario&quot;)&#10;        self.window.geometry(&quot;320x300&quot;)&#10;        self.window.grab_set()  # la hace modal&#10;&#10;        # campos&#10;        ctk.CTkLabel(self.window, text=&quot;Nombre:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(8, 2))&#10;        self.nombre_entry = ctk.CTkEntry(self.window)&#10;        self.nombre_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Edad:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.edad_entry = ctk.CTkEntry(self.window)&#10;        self.edad_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Género:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.genero_entry = ctk.CTkEntry(self.window)&#10;        self.genero_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Avatar (nombre de archivo en assets/):&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.avatar_entry = ctk.CTkEntry(self.window)&#10;        self.avatar_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        # botones&#10;        self.guardar_button = ctk.CTkButton(self.window, text=&quot;Guardar&quot;)&#10;        self.guardar_button.pack(side=&quot;right&quot;, padx=8, pady=12)&#10;&#10;        self.cancelar_button = ctk.CTkButton(self.window, text=&quot;Cancelar&quot;, command=self.window.destroy)&#10;        self.cancelar_button.pack(side=&quot;right&quot;, padx=(0, 8), pady=12)&#10;&#10;    def get_data(self) -&gt; dict:&#10;        &quot;&quot;&quot;Devuelve los valores del formulario como dict.&quot;&quot;&quot;&#10;        return {&#10;            &quot;nombre&quot;: self.nombre_entry.get().strip(),&#10;            &quot;edad&quot;: self.edad_entry.get().strip(),&#10;            &quot;genero&quot;: self.genero_entry.get().strip(),&#10;            &quot;avatar&quot;: self.avatar_entry.get().strip(),&#10;        }&#10;" />
              <option name="updatedContent" value="import customtkinter as ctk&#10;from typing import Callable, Optional, List&#10;from registro_usuarios_ctk.model.usuario_model import Usuario&#10;import tkinter&#10;&#10;&#10;class MainView:&#10;    &quot;&quot;&quot;Vista principal: grid de 2 columnas con lista a la izquierda y detalles a la derecha.&quot;&quot;&quot;&#10;&#10;    def __init__(self, root):&#10;        self.root = root&#10;        # crear la barra de menú (la vista sólo crea los contenedores)&#10;        self.menubar = tkinter.Menu(root)&#10;        root.config(menu=self.menubar)&#10;        self.menu_archivo = tkinter.Menu(self.menubar, tearoff=0)&#10;        self.menubar.add_cascade(label=&quot;Archivo&quot;, menu=self.menu_archivo)&#10;&#10;        # callbacks que el controlador asignará&#10;        self.on_seleccionar_usuario: Optional[Callable[[int], None]] = None&#10;        self.on_exit: Optional[Callable[[], None]] = None&#10;        self.on_search_change: Optional[Callable[[str], None]] = None&#10;        self.on_filter_change: Optional[Callable[[str], None]] = None&#10;        self.on_double_click: Optional[Callable[[int], None]] = None&#10;&#10;        # configurar grid&#10;        root.grid_columnconfigure(0, weight=1)&#10;        root.grid_columnconfigure(1, weight=2)&#10;        root.grid_rowconfigure(0, weight=1)&#10;        root.grid_rowconfigure(1, weight=0)&#10;&#10;        # panel izquierdo: lista scrollable&#10;        self.lista_usuarios_frame = ctk.CTkFrame(root)&#10;        self.lista_usuarios_frame.grid(row=0, column=0, sticky=&quot;nsew&quot;, padx=8, pady=8)&#10;&#10;        # título para la lista&#10;        self.lbl_usuarios_title = ctk.CTkLabel(self.lista_usuarios_frame, text=&quot;Usuarios&quot;, font=(&quot;Arial&quot;, 14, &quot;bold&quot;))&#10;        self.lbl_usuarios_title.pack(anchor=&quot;nw&quot;, padx=4, pady=(2, 6))&#10;&#10;        # Search and filter container&#10;        controls_frame = ctk.CTkFrame(self.lista_usuarios_frame)&#10;        controls_frame.pack(fill=&quot;x&quot;, padx=4, pady=(0, 6))&#10;&#10;        # búsqueda&#10;        search_lbl = ctk.CTkLabel(controls_frame, text=&quot;Buscar:&quot;)&#10;        search_lbl.pack(side=&quot;left&quot;, padx=(4, 6))&#10;        self.search_var = tkinter.StringVar()&#10;        self.search_entry = ctk.CTkEntry(controls_frame, textvariable=self.search_var)&#10;        self.search_entry.pack(side=&quot;left&quot;, fill=&quot;x&quot;, expand=True, padx=(0, 6))&#10;&#10;        # filtro de género&#10;        self.gender_var = tkinter.StringVar(value=&quot;Todos&quot;)&#10;        self.filter_option = ctk.CTkOptionMenu(controls_frame, values=[&quot;Todos&quot;, &quot;Masculino&quot;, &quot;Femenino&quot;, &quot;Otro&quot;], variable=self.gender_var, command=self._on_filter_selected)&#10;        self.filter_option.pack(side=&quot;left&quot;, padx=(0, 4))&#10;&#10;        # conectar trace para búsqueda&#10;        self.search_var.trace_add(&quot;write&quot;, lambda *_: self._on_search_text_changed())&#10;&#10;        self.lista_usuarios_scrollable = ctk.CTkScrollableFrame(self.lista_usuarios_frame)&#10;        self.lista_usuarios_scrollable.pack(fill=&quot;both&quot;, expand=True, padx=4, pady=4)&#10;&#10;        # panel derecho: detalles&#10;        self.detalles_frame = ctk.CTkFrame(root)&#10;        self.detalles_frame.grid(row=0, column=1, sticky=&quot;nsew&quot;, padx=8, pady=8)&#10;&#10;        # título para detalles&#10;        self.lbl_detalles_title = ctk.CTkLabel(self.detalles_frame, text=&quot;Detalles del Usuario&quot;, font=(&quot;Arial&quot;, 14, &quot;bold&quot;))&#10;        self.lbl_detalles_title.pack(anchor=&quot;nw&quot;, pady=(2, 6))&#10;&#10;        self.lbl_nombre = ctk.CTkLabel(self.detalles_frame, text=&quot;Nombre: -&quot;)&#10;        self.lbl_nombre.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_edad = ctk.CTkLabel(self.detalles_frame, text=&quot;Edad: -&quot;)&#10;        self.lbl_edad.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_genero = ctk.CTkLabel(self.detalles_frame, text=&quot;Género: -&quot;)&#10;        self.lbl_genero.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        self.lbl_avatar = ctk.CTkLabel(self.detalles_frame, text=&quot;Avatar: -&quot;)&#10;        self.lbl_avatar.pack(anchor=&quot;nw&quot;, pady=4)&#10;&#10;        # footer: ocupar la segunda fila (row=1) y spanear ambas columnas&#10;        self.footer_frame = ctk.CTkFrame(root)&#10;        self.footer_frame.grid(row=1, column=0, columnspan=2, sticky=&quot;ew&quot;, padx=8, pady=(0, 8))&#10;&#10;        # status label a la izquierda&#10;        self.status_var = tkinter.StringVar(value=&quot;Listo&quot;)&#10;        self.status_label = ctk.CTkLabel(self.footer_frame, textvariable=self.status_var, anchor=&quot;w&quot;)&#10;        self.status_label.pack(side=&quot;left&quot;, padx=8)&#10;&#10;        # botón Salir a la derecha&#10;        self.btn_salir = ctk.CTkButton(self.footer_frame, text=&quot;Salir&quot;, command=self._on_exit_clicked)&#10;        self.btn_salir.pack(side=&quot;right&quot;, padx=8, pady=4)&#10;&#10;        # botón Añadir a la izquierda del centro&#10;        self.btn_anadir = ctk.CTkButton(self.footer_frame, text=&quot;Añadir&quot;)&#10;        self.btn_anadir.pack(side=&quot;right&quot;, padx=8, pady=4)&#10;&#10;    def _on_exit_clicked(self):&#10;        if self.on_exit:&#10;            try:&#10;                self.on_exit()&#10;                return&#10;            except Exception:&#10;                # si el callback falla, fallback a cerrar la ventana&#10;                pass&#10;        try:&#10;            self.root.destroy()&#10;        except Exception:&#10;            pass&#10;&#10;    def _on_search_text_changed(self):&#10;        if self.on_search_change:&#10;            try:&#10;                self.on_search_change(self.search_var.get())&#10;            except Exception:&#10;                pass&#10;&#10;    def _on_filter_selected(self, value: str):&#10;        if self.on_filter_change:&#10;            try:&#10;                self.on_filter_change(value)&#10;            except Exception:&#10;                pass&#10;&#10;    def actualizar_lista_usuarios(self, usuarios: List[Usuario], on_seleccionar_callback: Callable[[int], None], on_double_click_callback: Optional[Callable[[int], None]] = None):&#10;        &quot;&quot;&quot;Rellena el CTkScrollableFrame con botones para cada usuario.&#10;        Cada botón llama al callback pasado con el índice del usuario.&#10;        &quot;&quot;&quot;&#10;        # limpiar contenido previo&#10;        for child in self.lista_usuarios_scrollable.winfo_children():&#10;            child.destroy()&#10;&#10;        for i, usuario in enumerate(usuarios):&#10;            btn = ctk.CTkButton(&#10;                self.lista_usuarios_scrollable,&#10;                text=usuario.nombre,&#10;                command=lambda idx=i: on_seleccionar_callback(idx),&#10;            )&#10;            # bind doble clic si nos dieron el callback&#10;            if on_double_click_callback:&#10;                try:&#10;                    btn.bind(&quot;&lt;Double-Button-1&gt;&quot;, lambda e, idx=i: on_double_click_callback(idx))&#10;                except Exception:&#10;                    # algunos widgets podrían no soportar bind en ciertas versiones, ignorar&#10;                    pass&#10;            btn.pack(fill=&quot;x&quot;, padx=5, pady=2)&#10;&#10;    def mostrar_detalles_usuario(self, usuario: Optional[Usuario]):&#10;        &quot;&quot;&quot;Actualiza los CTkLabel con los datos del usuario.&quot;&quot;&quot;&#10;        if usuario is None:&#10;            self.lbl_nombre.configure(text=&quot;Nombre: -&quot;)&#10;            self.lbl_edad.configure(text=&quot;Edad: -&quot;)&#10;            self.lbl_genero.configure(text=&quot;Género: -&quot;)&#10;            self.lbl_avatar.configure(text=&quot;Avatar: -&quot;)&#10;            return&#10;&#10;        self.lbl_nombre.configure(text=f&quot;Nombre: {usuario.nombre}&quot;)&#10;        self.lbl_edad.configure(text=f&quot;Edad: {usuario.edad}&quot;)&#10;        self.lbl_genero.configure(text=f&quot;Género: {usuario.genero}&quot;)&#10;        self.lbl_avatar.configure(text=f&quot;Avatar: {usuario.avatar or '-'}&quot;)&#10;&#10;    def set_status(self, message: str):&#10;        &quot;&quot;&quot;Actualiza la barra de estado (izquierda).&quot;&quot;&quot;&#10;        try:&#10;            self.status_var.set(message)&#10;        except Exception:&#10;            pass&#10;&#10;&#10;class AddUserView:&#10;    &quot;&quot;&quot;Ventana modal para añadir un nuevo usuario.&quot;&quot;&quot;&#10;&#10;    def __init__(self, master, usuario: Optional[Usuario] = None):&#10;        self.window = ctk.CTkToplevel(master)&#10;        self.window.title(&quot;Añadir Nuevo Usuario&quot; if usuario is None else &quot;Editar Usuario&quot;)&#10;        self.window.geometry(&quot;320x300&quot;)&#10;        self.window.grab_set()  # la hace modal&#10;&#10;        # campos&#10;        ctk.CTkLabel(self.window, text=&quot;Nombre:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(8, 2))&#10;        self.nombre_entry = ctk.CTkEntry(self.window)&#10;        self.nombre_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Edad:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.edad_entry = ctk.CTkEntry(self.window)&#10;        self.edad_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Género:&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.genero_entry = ctk.CTkEntry(self.window)&#10;        self.genero_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        ctk.CTkLabel(self.window, text=&quot;Avatar (nombre de archivo en assets/):&quot;).pack(anchor=&quot;w&quot;, padx=8, pady=(0, 2))&#10;        self.avatar_entry = ctk.CTkEntry(self.window)&#10;        self.avatar_entry.pack(fill=&quot;x&quot;, padx=8, pady=(0, 8))&#10;&#10;        # botones&#10;        self.guardar_button = ctk.CTkButton(self.window, text=&quot;Guardar&quot;)&#10;        self.guardar_button.pack(side=&quot;right&quot;, padx=8, pady=12)&#10;&#10;        self.cancelar_button = ctk.CTkButton(self.window, text=&quot;Cancelar&quot;, command=self.window.destroy)&#10;        self.cancelar_button.pack(side=&quot;right&quot;, padx=(0, 8), pady=12)&#10;&#10;        # si nos pasaron un usuario, prefilling&#10;        if usuario is not None:&#10;            try:&#10;                self.nombre_entry.insert(0, usuario.nombre)&#10;                self.edad_entry.insert(0, str(usuario.edad))&#10;                self.genero_entry.insert(0, usuario.genero)&#10;                if usuario.avatar:&#10;                    self.avatar_entry.insert(0, usuario.avatar)&#10;                self.guardar_button.configure(text=&quot;Actualizar&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;    def get_data(self) -&gt; dict:&#10;        &quot;&quot;&quot;Devuelve los valores del formulario como dict.&quot;&quot;&quot;&#10;        return {&#10;            &quot;nombre&quot;: self.nombre_entry.get().strip(),&#10;            &quot;edad&quot;: self.edad_entry.get().strip(),&#10;            &quot;genero&quot;: self.genero_entry.get().strip(),&#10;            &quot;avatar&quot;: self.avatar_entry.get().strip(),&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>